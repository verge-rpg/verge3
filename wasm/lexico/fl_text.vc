// -------------------------------------------------------------- --- -- -
// FL_TEXT.VC. Text and fonts functions library
// -------------------------------------------------------------- --- -- -

// Defines

#define maxfonts		0		// Maximum number of font slots
#define maxwraplines		10		// Maximum lines of text to wrap to

// Globals

int font[maxfonts];				// Stores fonts
string textwrap[maxwraplines];			// Stores output from the wrap text routine

// -----------------------------------------------------------------------

// Load all fonts into memory. Fonts must be named "font<number>.png"!
void LoadFonts()
{
int loop;
for(loop = 0; loop < maxfonts; loop++)
	{
	font[loop] = LoadFont("fonts/font"+str(loop)+".png");
	EnableVariableWidth(font[loop]);
	}
}

// -----------------------------------------------------------------------

// Frees all loaded fonts from memory
void FreeFonts()
{
int loop;
for(loop = 0; loop < maxfonts; loop++)
	{
	FreeFont(font[loop]);
	}
}
/*
// -----------------------------------------------------------------------

// A variant on tSB's wraptext function. Modified to work with v3's funky features.
// It returns the total number of lines the passed string was cut into. To access
// the cut string, you'll find it in the textwrap[] array (declared above)
int WrapText(int txtfont, int maxlinelength, string s)
{
int curline, curpos, countpos;
int charwrap;
string tempst, countst;

curline=0;
tempst=s;
charwrap = maxlinelength;

// Just one line of text? Don't bother processing it
if (TextWidth(txtfont, s) < charwrap)
	{
	textwrap[0]=s;
	return 1;
	}

// Calculate how many characters fit in a string that's the maximum line length
// and stick this number in charwrap
while (len(tempst)>0 && curline<maxwraplines)
	{
	countst = "";
	charwrap = 0;
	countpos = 1;

	if (TextWidth(txtfont, tempst) >= maxlinelength)
 		{
		while(TextWidth(txtfont, countst) <= maxlinelength)
			{
			countst = left(tempst, countpos);
			countpos++;
			}
		charwrap = len(countst)-1;
		}
	else
		{
		charwrap = len(tempst);
		tempst = tempst+" ";
		}

// Start at the charwrap-th char and go backwards until we find a space.
// Chop it there
 	for (curpos = charwrap; curpos>0; curpos--)
 	 	{
 	 	if (strcmp(mid(tempst,curpos,1), " ") = 0)
 	 		{       
 	 		textwrap[curline]=left(tempst,curpos);
 	 		tempst=right(tempst,len(tempst)-curpos-1);
 	 		curline++;
 	 		curpos=0-1; // Jump out of the loop
 	 		}
 	   	}
	}
return curline;
}
*/
// -----------------------------------------------------------------------

